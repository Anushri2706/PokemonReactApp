name: My CodeQL scanner
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
    paths-ignore:
      - ".github/**"

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  analyze:
    name: Analyze
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
      security-events: write
    strategy:
      fail-fast: false
      matrix:
        language: [ 'javascript' ]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language }}

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          output: ./codeql-results
          format: sarif

      - name: Upload SARIF results
        uses: actions/upload-artifact@v4
        with:
          name: codeql-sarif
          path: codeql-results/**/*.sarif

  create_issues:
    name: Create issues from SARIF
    runs-on: ubuntu-latest
    needs: analyze
    permissions:
      contents: read
      security-events: read
      issues: write
    steps:
      - name: Download CodeQL SARIF results
        uses: actions/download-artifact@v4
        with:
          name: codeql-sarif
          path: sarif-result

      - name: Parse SARIF and create issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");
            const sarifDir = "sarif-result";
            const sarifFiles = fs.readdirSync(sarifDir).filter(f => f.endsWith(".sarif"));

            for (const sarifFile of sarifFiles) {
              const sarifPath = path.join(sarifDir, sarifFile);
              const sarif = JSON.parse(fs.readFileSync(sarifPath, "utf8"));

              for (const run of sarif.runs || []) {
                // Build lookup for rules and their properties
                const ruleMap = {};
                for (const rule of run.tool?.driver?.rules || []) {
                  ruleMap[rule.id] = rule;
                }

                for (const result of run.results || []) {
                  const severity = result.level || "note";

                  // Prefer result.properties, fallback to rule properties
                  let securitySeverity = 0;
                  if (result.properties?.["security-severity"]) {
                    securitySeverity = parseFloat(result.properties["security-severity"]);
                  } else if (
                    result.ruleId &&
                    ruleMap[result.ruleId]?.properties?.["security-severity"]
                  ) {
                    securitySeverity = parseFloat(
                      ruleMap[result.ruleId].properties["security-severity"]
                    );
                  }

                  // Only act if it's error OR High/Critical (>= 7.0)
                  if (!(severity === "error" || securitySeverity >= 7.0)) {
                    continue;
                  }

                  const message = result.message?.text || "";
                  const ruleId = result.ruleId || result.rule?.id || "unknown-rule";
                  const file =
                    result.locations?.[0]?.physicalLocation?.artifactLocation?.uri ||
                    "unknown file";
                  const issueTitle = `CodeQL: [${severity.toUpperCase()}] ${ruleId}`;

                  const { data: existingIssues } = await github.rest.issues.listForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: "open",
                    labels: "auto-generated",
                    per_page: 100
                  });

                  const duplicate = existingIssues.find(
                    issue => issue.title === issueTitle
                  );

                  if (!duplicate) {
                    const issueBody = [
                      "**High/Critical CodeQL finding**",
                      `**Rule:** ${ruleId}`,
                      `**Message:** ${message}`,
                      `**File:** ${file}`,
                      `**Security severity:** ${securitySeverity}`,
                      "",
                      "This issue was auto-created and assigned to **GitHub Copilot Autofix**."
                    ].join("\n");

                    await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: issueTitle,
                      body: issueBody,
                      assignees: ["Copilot"],
                      labels: ["auto-generated"]
                    });
                  }
                }
              }
            }
